## 循环

> 循环应该是各种语言都至关重要的，接下来看看 JavaScript 中的循环都有哪些吧！

先看一下，`for in` 和 `for of`, 因为，我总是记不清楚这两者的区别，那就把它写在最重要的位置

#### for in

先看一些 MDN 的解释：for...in 语句以任意顺序迭代一个**对象**的除 Symbol 以外的**可枚举属性**，包括继承的可枚举属性。
MDN 官方还体贴的解释了`for in` 的使用场景，原话如下：

`for ... in` 是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用`Array.prototype.forEach()`和`for ... of`，那么`for ... in`的到底有什么用呢？
它最常用的地方应该是用于**调试**，可以更方便的去检查对象属性（通过输出到控制台或其他方式）。尽管对于处理存储数据，数组更实用些，但是你在处理有 key-value 数据（比如属性用作“键”），需要检查其中的任何键是否为某值的情况时，还是推荐用`for ... in`。
**for in 特点**

1. for ... in 循环返回的值都是数据结构的键值名；
2. 遍历对象返回的对象的 key 值，遍历数组返回的数组的下标 (key)。
3. for ... in 循环不仅可以遍历数字键名，还会遍历原型上的值和手动添加的其他键
4. 特别情况下，for ... in 循环会以看起来任意的顺序遍历键名
   总结：特别适合遍历对象
   这里我给自己弄了一个记住`for ... in`的方法：就是”迎对象“，大意为：谈恋爱对象要来找你，你需要去迎接一下啊！！！

#### for of

先看一下 MDN 的解释：
for...of 语句在**可迭代对象**（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用**自定义迭代钩子**，并为每个不同属性的值执行语句
可迭代对象：拥有迭代器对象（`iterator`）的集合，我们也就知道了对象类型是没有迭代器对象的
**for of 特点**

1. 一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以使用 for of 循环
2. for of 不同与 forEach, 它可以与 break、continue 和 return 配合使用，也就是说 for of 循环可以随时退出循环。
3. ES6 借鉴 C++、Java、C# 和 Python 语言，引入了 for...of 循环，作为遍历所有数据结构的统一的方法。
4. 部署了 Symbol.iteratoer 属性的接口
   - Array
   - Map
   - Set
   - String
   - arguments
   - Nodelist(dom 列表集合)

我们来看一下 `for in` 和 `for of` 的区别吧！

1. 简单来说就是它们两者都可以用于遍历，不过 for in 遍历的是数组的索引（index），而 for of 遍历的是数组元素值（value）
2. for in 遍历的是数组的索引（即键名），而 for of 遍历的是数组元素值

接下来再看看一些其他的循环实现方式

#### while 循环和 do while 循环

他们的区别是前者**先判断再执行** 后者**先执行再判断**，所以后者即使是初始条件不成立，也会执行一次

#### for 循环

1. for 有三个表达式：① 声明循环变量；② 判断循环条件；③ 更新循环变量；三个表达式之间，用;分割，for 循环三个表达式都可以省略，但是两个“;”缺一不可。
2. for 循环的执行特点：先判断再执行，与 while 相同
3. for 循环三个表达式都可以有多部分组成，第二部分多个判断条件用&& ||连接，第一三部分用逗号分割；
   for 循环常用于执行执行循环，需要使用到索引的情况
   **最后再看一下我们的循环控制语句**
4. break：跳出本层循环，继续执行循环后面的语句。如果循环有多层，则 break 只能跳出一层。
5. continue：跳过本次循环剩余的代码，继续执行下一次循环。
   - 对与 for 循环，continue 之后执行的语句，是循环变量更新语句 i++；
     - 对于 while、do-while 循环，continue 之后执行的语句，是循环条件判断；
     - 因此，使用这两个循环时，必须将 continue 放到 i++ 之后使用，否则，continue 将跳过 i++ 进入死循环。

总结下来！我们可以看见 JavaScript 实现循环的方式还是挺多的，但是我们也可以看见每一个实现方式都有自己独特的使用场景，定位，结合使用场景再学习技术，可能会对技术理解更加深刻
